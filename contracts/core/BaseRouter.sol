// Copyright (C) 2020 Zerion Inc. <https://zerion.io>
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <https://www.gnu.org/licenses/>.
//
// SPDX-License-Identifier: LGPL-3.0-only

pragma solidity 0.7.6;

import { Input, Fee, Permit, TokenAmount, AmountType, PermitType } from "../shared/Structs.sol";
import { ERC20 } from "../interfaces/ERC20.sol";
import { SafeERC20 } from "../shared/SafeERC20.sol";
import { Base } from "./Base.sol";

abstract contract BaseRouter is Base {
    using SafeERC20 for ERC20;

    uint256 internal constant FEE_LIMIT = 1e16; // 1%
    uint256 internal constant DELIMITER = 1e18; // 100%

    event Executed(address indexed account, uint256 indexed share, address indexed beneficiary);
    event TokenTransfer(address indexed account, address indexed token, uint256 indexed amount);

    /**
     * @dev Calls the chosen permit() function.
     * @param token Address of the token to be called.
     * @param permit Permit type and calldata.
     */
    function callPermit(address token, Permit calldata permit) internal {
        (bool success, bytes memory returnData) =
            // solhint-disable-next-line avoid-low-level-calls
            token.call(
                abi.encodePacked(getPermitSelector(permit.permitType), permit.permitCallData)
            );

        // assembly revert opcode is used here as `returnData`
        // is already bytes array generated by the callee's revert()
        // solhint-disable-next-line no-inline-assembly
        assembly {
            if eq(success, 0) {
                revert(add(returnData, 32), returndatasize())
            }
        }
    }

    /**
     * @dev Transfers token from the accound address to the destination address.
     * Calls permit() function if allowance is not enough.
     * Handles fee if required.
     * @param account Address of the account to transfer tokens from.
     * @param destination Address of the destination to transfer tokens to.
     * @param input Token address, its amount, and amount type,
     *     as well as permit type and calldata.
     * @param fee Fee share and beneficiary address.
     * @return Amount after fee was charged.
     */
    function handleTokenInput(
        address account,
        address destination,
        Input calldata input,
        Fee calldata fee
    ) internal returns (uint256) {
        uint256 absoluteAmount = getAbsoluteAmount(account, input.tokenAmount);
        require(absoluteAmount > 0, "BR: zero token amount");

        address token = input.tokenAmount.token;

        if (absoluteAmount > ERC20(token).allowance(account, address(this))) {
            callPermit(token, input.permit);
        }

        uint256 feeAmount = handleTokenFee(account, token, absoluteAmount, fee);
        uint256 inputAmount = absoluteAmount - feeAmount;

        ERC20(token).safeTransferFrom(account, destination, inputAmount, "BR: input");
        emit TokenTransfer(account, token, inputAmount);

        return inputAmount;
    }

    /**
     * @dev Transfers Ether from the accound address to the destination address.
     * Handles fee if required.
     * @param account Address of the account to transfer tokens from.
     * @param destination Address of the destination to transfer tokens to.
     * @param fee Fee share and beneficiary address.
     * @return Amount after fee was charged.
     */
    function handleETHInput(
        address account,
        address destination,
        Fee calldata fee
    ) internal returns (uint256) {
        require(msg.value > 0, "BR: zero ETH amount");

        uint256 feeAmount = handleETHFee(fee);
        uint256 inputAmount = msg.value - feeAmount;

        transferEther(destination, inputAmount, "UR: bad ETH input");
        emit TokenTransfer(account, ETH, inputAmount);

        return inputAmount;
    }

    /**
     * @dev Handles token fee if required.
     * @param account Address of the account to transfer fee from.
     * @param token Address of the token to be transfered.
     * @param absoluteAmount Absolute token amount to be transfered.
     * @param fee Fee share and beneficiary address.
     * @return Fee amount.
     */
    function handleTokenFee(
        address account,
        address token,
        uint256 absoluteAmount,
        Fee calldata fee
    ) internal returns (uint256) {
        uint256 feeAmount = mul_(absoluteAmount, fee.share) / DELIMITER;

        if (feeAmount > 0) {
            ERC20(token).safeTransferFrom(account, fee.beneficiary, feeAmount, "BR: fee");
        }

        return feeAmount;
    }

    /**
     * @dev Handles Ether fee if required.
     * @param fee Fee share and beneficiary address.
     * @return Fee amount.
     */
    function handleETHFee(Fee calldata fee) internal returns (uint256) {
        uint256 feeAmount = mul_(msg.value, fee.share) / DELIMITER;

        if (feeAmount > 0) {
            transferEther(fee.beneficiary, feeAmount, "BR: bad ETH fee");
        }

        return feeAmount;
    }

    /**
     * @param account Address of the account to transfer token from.
     * @param tokenAmount Token address, its amount, and amount type.
     * @return Absolute token amount.
     */
    function getAbsoluteAmount(address account, TokenAmount calldata tokenAmount)
        internal
        view
        returns (uint256)
    {
        address token = tokenAmount.token;
        AmountType amountType = tokenAmount.amountType;
        uint256 amount = tokenAmount.amount;

        require(
            amountType == AmountType.Relative || amountType == AmountType.Absolute,
            "BR: bad amount type"
        );

        if (amountType == AmountType.Relative) {
            require(amount <= DELIMITER, "BR: bad amount");
            if (amount == DELIMITER) {
                return ERC20(token).balanceOf(account);
            } else {
                return mul_(ERC20(token).balanceOf(account), amount) / DELIMITER;
            }
        } else {
            return amount;
        }
    }

    /**
     * @param permitType PermitType enum variable with permit type.
     * @return permit() function signature corresponding to the given permit type.
     */
    function getPermitSelector(PermitType permitType) internal pure returns (bytes4) {
        require(
            permitType == PermitType.EIP2612 ||
                permitType == PermitType.DAI ||
                permitType == PermitType.Yearn,
            "BR: permit is required but not provided"
        );

        // Constants of non-value type not yet implemented,
        // so we have to use else-if's.
        //    bytes4[3] internal constant PERMIT_SELECTORS = [
        //        // PermitType.EIP2612
        //        // keccak256(abi.encodePacked('permit(address,address,uint256,uint256,uint8,bytes32,bytes32)'))
        //        0xd505accf,
        //        // PermitType.DAI
        //        // keccak256(abi.encodePacked('permit(address,address,uint256,uint256,bool,uint8,bytes32,bytes32)'))
        //        0x8fcbaf0c,
        //        // PermitType.Yearn
        //        // keccak256(abi.encodePacked('permit(address,address,uint256,uint256,bytes[65])'))
        //        0x53ab5ce3
        //    ];

        if (permitType == PermitType.EIP2612) {
            return 0xd505accf;
        } else if (permitType == PermitType.DAI) {
            return 0x8fcbaf0c;
        } else if (permitType == PermitType.Yearn) {
            return 0x53ab5ce3;
        } else {
            return bytes4(0);
        }
    }

    /**
     * @dev Safe multiplication operation.
     */
    function mul_(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "BR: mul_ overflow");

        return c;
    }

    /**
     * @dev Safe addition operation.
     */
    function add_(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "BR: add_ overflow");

        return c;
    }
}
